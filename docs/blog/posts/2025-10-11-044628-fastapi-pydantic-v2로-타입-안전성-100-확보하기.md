---
date: 2025-10-11T04:46:28+09:00
title: "FastAPI + Pydantic V2로 타입 안전성 100% 확보하기"
description: "FastAPI와 Pydantic V2를 결합해 타입 안전한 REST API를 구축하는 실무 패턴을 소개합니다. 모델 검증, 커스텀 타입, 에러 처리까지 실제 프로젝트에 바로 적용 가능한 코드와 팁을 담았습니다."
categories:
  - Programming
tags:
  - FastAPI
  - Pydantic
  - Python
  - REST API
  - 타입안전성
---

> FastAPI와 Pydantic V2를 결합해 타입 안전한 REST API를 구축하는 실무 패턴을 소개합니다. 모델 검증, 커스텀 타입, 에러 처리까지 실제 프로젝트에 바로 적용 가능한 코드와 팁을 담았습니다.


## FastAPI와 Pydantic V2, 왜 함께 써야 할까요?

Python으로 API를 개발하면서 가장 답답했던 순간이 언제였나요? 저는 클라이언트가 보낸 데이터가 예상과 달라서 런타임 에러가 발생했을 때였습니다. FastAPI와 Pydantic V2의 조합은 바로 이런 문제를 컴파일 타임에 잡아내는 강력한 솔루션이에요.

Pydantic V2는 기존 버전 대비 17배 빠른 성능을 자랑하며, Rust 기반 코어로 완전히 재작성되었습니다. FastAPI와 결합하면 자동 문서화, 데이터 검증, 타입 힌팅이 하나의 흐름으로 연결되죠. 이제 본격적으로 실무에서 바로 쓸 수 있는 패턴들을 살펴볼게요.

## 기본 모델 정의와 검증 로직 구축하기

먼저 Pydantic V2의 강력한 검증 기능을 활용한 모델을 만들어봅시다.

python
from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import Optional
from datetime import datetime

class UserCreate(BaseModel):
    model_config = ConfigDict(str_strip_whitespace=True)
    
    username: str = Field(min_length=3, max_length=20, pattern=r'^[a-zA-Z0-9_]+$')
    email: str = Field(pattern=r'^[\w\.-]+@[\w\.-]+\.\w+$')
    age: Optional[int] = Field(default=None, ge=0, le=150)
    created_at: datetime = Field(default_factory=datetime.now)
    
    @field_validator('email')
    @classmethod
    def lowercase_email(cls, v: str) -> str:
        return v.lower()


V2에서 주목할 점은 `model_config`를 통한 설정 방식입니다. 기존 `Config` 클래스 대신 `ConfigDict`를 사용하며, 더욱 명확한 타입 힌팅을 제공합니다. `str_strip_whitespace`는 자동으로 공백을 제거해주죠.

**💡 실무 팁**: `field_validator`는 V2에서 `validator`를 대체합니다. `@classmethod` 데코레이터를 반드시 함께 사용해야 하며, 여러 필드를 한 번에 검증할 때는 `mode='before'` 옵션을 활용하세요.

## FastAPI 엔드포인트에서 타입 안전성 극대화하기

이제 정의한 모델을 FastAPI와 통합해봅시다. 핵심은 요청과 응답 모델을 명확히 분리하는 것입니다.

python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel

app = FastAPI()

class UserResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    
    id: int
    username: str
    email: str
    created_at: datetime

@app.post("/users/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate) -> UserResponse:
    # 여기서 user는 이미 검증된 상태입니다
    # 데이터베이스 저장 로직
    new_user = await save_to_db(user)
    return UserResponse.model_validate(new_user)


`response_model`을 명시하면 FastAPI가 자동으로 응답 데이터를 검증하고 직렬화합니다. V2의 `from_attributes=True`(이전 `orm_mode`)는 ORM 객체를 Pydantic 모델로 변환할 때 필수예요.

**핵심 포인트**: `model_validate()` 메서드는 V2에서 `parse_obj()`를 대체합니다. 더 명확한 네이밍으로 가독성이 향상되었죠.

## 고급 검증 패턴: 커스텀 타입과 의존성 주입

실무에서는 더 복잡한 검증이 필요합니다. Pydantic V2의 `Annotated` 타입과 FastAPI의 의존성 주입을 결합해보세요.

python
from typing import Annotated
from pydantic import AfterValidator, PlainSerializer
from fastapi import Depends

def validate_unique_username(username: str) -> str:
    if check_username_exists(username):
        raise ValueError('Username already exists')
    return username

UniqueUsername = Annotated[
    str,
    AfterValidator(validate_unique_username),
    Field(min_length=3)
]

class AdvancedUserCreate(BaseModel):
    username: UniqueUsername
    email: str

@app.post("/users/advanced/")
async def create_advanced_user(
    user: AdvancedUserCreate,
    current_user: User = Depends(get_current_user)
) -> UserResponse:
    # 검증은 이미 완료된 상태
    return await create_user_logic(user, current_user)


`Annotated` 타입은 V2의 핵심 기능으로, 검증 로직을 재사용 가능한 타입으로 만들 수 있습니다. `AfterValidator`는 Pydantic의 기본 검증 이후 실행되며, 데이터베이스 조회 같은 비동기 작업도 가능해요.

## 에러 처리와 커스텀 응답 만들기

타입 안전성은 에러 처리까지 포함해야 완성됩니다. Pydantic의 검증 에러를 사용자 친화적으로 변환해봅시다.

python
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from pydantic import ValidationError

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    errors = []
    for error in exc.errors():
        errors.append({
            "field": ".".join(str(x) for x in error["loc"][1:]),
            "message": error["msg"],
            "type": error["type"]
        })
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": errors}
    )


V2의 에러 구조는 더 상세해졌습니다. `error["loc"]`은 에러 위치를, `error["type"]`은 검증 실패 유형을 명확히 알려주죠. 이를 활용하면 프론트엔드에서 필드별로 정확한 에러 메시지를 표시할 수 있습니다.

**실무 적용 팁**: 프로덕션 환경에서는 에러 메시지에 민감한 정보가 노출되지 않도록 주의하세요. `model_config`의 `hide_input_in_errors=True` 옵션을 활용하면 입력값이 에러 메시지에 포함되지 않습니다.

## 마치며: 타입 안전성이 가져다주는 가치

FastAPI와 Pydantic V2의 조합은 단순히 타입 체크를 넘어 개발 생산성을 극대화합니다. IDE의 자동완성, 런타임 에러 사전 방지, 자동 문서화까지 모두 연결되죠. 처음엔 모델 정의가 번거롭게 느껴질 수 있지만, 장기적으로 유지보수 비용을 크게 줄여줍니다.

다음 프로젝트에서는 이 패턴들을 적용해보세요. 특히 팀 프로젝트라면 타입 안전성이 주는 명확성이 협업 효율을 눈에 띄게 높여줄 거예요!

<!-- more -->

---

*이 글은 AI가 자동으로 작성했습니다.*
