---
date: 2025-10-08 12:00:00
title: "Python 데코레이터 완벽 이해하기: 실전 예제로 배우는 활용법"
description: "Python 데코레이터의 개념부터 실전 활용까지, 실행 시간 측정, 로깅, 권한 확인 등 실용적인 예제로 쉽게 배워보세요."
categories:
  - Technology
tags:
  - Python
  - 데코레이터
  - 프로그래밍
  - 함수형프로그래밍
  - 초중급개발자
---

# Python 데코레이터 완벽 이해하기: 실전 예제로 배우는 활용법

> Python 데코레이터의 개념부터 실전 활용까지, 실행 시간 측정, 로깅, 권한 확인 등 실용적인 예제로 쉽게 배워보세요.


# Python 데코레이터 완벽 이해하기: 실전 예제로 배우는 활용법

## 서론

파이썬 코드를 보다 보면 함수 위에 `@`로 시작하는 이상한 문법을 본 적이 있으신가요? 이것이 바로 **데코레이터(Decorator)**입니다. 처음에는 어렵게 느껴지지만, 한번 이해하면 코드를 훨씬 깔끔하고 효율적으로 만들 수 있는 강력한 도구입니다.

오늘은 데코레이터가 무엇인지, 어떻게 작동하는지, 그리고 실무에서 어떻게 활용할 수 있는지 쉽게 알아보겠습니다.

## 데코레이터란 무엇인가?

데코레이터는 **함수를 감싸서 기능을 추가하는 함수**입니다. 기존 함수의 코드를 수정하지 않고도 새로운 기능을 덧붙일 수 있죠.

### 기본 개념

```python
def simple_decorator(func):
    def wrapper():
        print("함수 실행 전")
        func()
        print("함수 실행 후")
    return wrapper

@simple_decorator
def say_hello():
    print("안녕하세요!")

say_hello()
# 출력:
# 함수 실행 전
# 안녕하세요!
# 함수 실행 후
```

위 코드에서 `@simple_decorator`는 `say_hello` 함수를 데코레이터로 감싼 것입니다.

## 실전 예제

### 1. 실행 시간 측정 데코레이터

함수가 얼마나 걸리는지 측정하는 데코레이터는 성능 최적화에 유용합니다.

```python
import time
from functools import wraps

def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 실행시간: {end-start:.4f}초")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(2)
    return "완료!"

result = slow_function()
# 출력: slow_function 실행시간: 2.0012초
```

### 2. 로깅 데코레이터

함수 호출을 자동으로 기록하는 데코레이터입니다.

```python
def logger(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"[LOG] {func.__name__} 호출됨")
        print(f"[LOG] 인자: {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"[LOG] 반환값: {result}")
        return result
    return wrapper

@logger
def add(a, b):
    return a + b

add(5, 3)
# 출력:
# [LOG] add 호출됨
# [LOG] 인자: (5, 3), {}
# [LOG] 반환값: 8
```

### 3. 권한 확인 데코레이터

API나 웹 개발에서 자주 사용되는 패턴입니다.

```python
def require_auth(func):
    @wraps(func)
    def wrapper(user, *args, **kwargs):
        if not user.get('is_authenticated'):
            return "접근 권한이 없습니다."
        return func(user, *args, **kwargs)
    return wrapper

@require_auth
def view_dashboard(user):
    return f"{user['name']}님의 대시보드"

user1 = {'name': '홍길동', 'is_authenticated': True}
user2 = {'name': '손님', 'is_authenticated': False}

print(view_dashboard(user1))  # 홍길동님의 대시보드
print(view_dashboard(user2))  # 접근 권한이 없습니다.
```

## 데코레이터 체이닝

여러 데코레이터를 동시에 사용할 수도 있습니다.

```python
@timer
@logger
def complex_function(x):
    return x * 2

complex_function(10)
```

## 실무 활용 팁

1. **`@wraps` 사용하기**: `functools.wraps`를 사용하면 원본 함수의 메타데이터를 유지할 수 있습니다.
2. **재사용성**: 공통 로직(로깅, 캐싱, 인증)은 데코레이터로 만들어 재사용하세요.
3. **Flask/Django**: 웹 프레임워크에서 `@app.route`, `@login_required` 같은 데코레이터를 자주 볼 수 있습니다.

## 결론

데코레이터는 처음에는 어렵게 느껴질 수 있지만, **코드의 중복을 줄이고 가독성을 높이는** 파이썬의 강력한 기능입니다. 실행 시간 측정, 로깅, 권한 확인 등 반복적인 작업을 데코레이터로 분리하면 훨씬 깔끔한 코드를 작성할 수 있습니다.

오늘 배운 예제들을 직접 실행해보고, 여러분의 프로젝트에 적용해보세요. 데코레이터를 사용하면 더 pythonic한 코드를 작성할 수 있을 것입니다!

<!-- more -->

---

*이 글은 AI가 자동으로 작성했습니다.*
