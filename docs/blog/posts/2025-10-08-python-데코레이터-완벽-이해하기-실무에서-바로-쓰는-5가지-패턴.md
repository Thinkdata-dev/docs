---
date: 2025-10-08 11:00:00
title: "Python 데코레이터 완벽 이해하기: 실무에서 바로 쓰는 5가지 패턴"
description: "Python 데코레이터의 개념부터 실무에서 자주 쓰이는 5가지 패턴(실행시간 측정, 로깅, 권한확인, 캐싱, 재시도)까지 예제와 함께 쉽게 설명합니다."
categories:
  - Technology
tags:
  - Python
  - 데코레이터
  - 함수형프로그래밍
  - 클린코드
  - 초중급개발자
---

# Python 데코레이터 완벽 이해하기: 실무에서 바로 쓰는 5가지 패턴

> Python 데코레이터의 개념부터 실무에서 자주 쓰이는 5가지 패턴(실행시간 측정, 로깅, 권한확인, 캐싱, 재시도)까지 예제와 함께 쉽게 설명합니다.


# Python 데코레이터 완벽 이해하기: 실무에서 바로 쓰는 5가지 패턴

## 서론

파이썬 코드를 보다 보면 함수 위에 `@`로 시작하는 이상한 문법을 본 적이 있으신가요? 바로 **데코레이터(Decorator)**입니다. 처음엔 어렵게 느껴지지만, 한번 이해하면 코드를 훨씬 깔끔하고 효율적으로 작성할 수 있습니다.

오늘은 데코레이터의 기본 개념부터 실무에서 자주 사용하는 패턴까지 쉽게 알아보겠습니다.

## 데코레이터란?

데코레이터는 **함수를 꾸며주는 함수**입니다. 기존 함수의 코드를 수정하지 않고도 기능을 추가할 수 있죠.

### 기본 문법

```python
def my_decorator(func):
    def wrapper():
        print("함수 실행 전")
        func()
        print("함수 실행 후")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# 출력:
# 함수 실행 전
# Hello!
# 함수 실행 후
```

`@my_decorator`는 사실 `say_hello = my_decorator(say_hello)`와 같은 의미입니다.

## 실무 활용 패턴 5가지

### 1. 실행 시간 측정

```python
import time
from functools import wraps

def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 실행 시간: {end-start:.4f}초")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
    return "완료"
```

### 2. 로깅

```python
def logger(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"[LOG] {func.__name__} 호출됨")
        print(f"[LOG] 인자: {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"[LOG] 반환값: {result}")
        return result
    return wrapper

@logger
def add(a, b):
    return a + b

add(3, 5)
```

### 3. 권한 확인

```python
def require_auth(func):
    @wraps(func)
    def wrapper(user, *args, **kwargs):
        if not user.get("is_authenticated"):
            raise PermissionError("로그인이 필요합니다")
        return func(user, *args, **kwargs)
    return wrapper

@require_auth
def delete_post(user, post_id):
    return f"게시글 {post_id} 삭제됨"
```

### 4. 캐싱 (메모이제이션)

```python
def memoize(func):
    cache = {}
    @wraps(func)
    def wrapper(*args):
        if args in cache:
            print("캐시에서 가져옴")
            return cache[args]
        result = func(*args)
        cache[args] = result
        return result
    return wrapper

@memoize
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

### 5. 재시도 로직

```python
def retry(max_attempts=3):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"시도 {attempt+1} 실패: {e}")
                    if attempt == max_attempts - 1:
                        raise
        return wrapper
    return decorator

@retry(max_attempts=3)
def unstable_api_call():
    # API 호출 코드
    pass
```

## 핵심 팁

1. **`@wraps` 사용하기**: `functools.wraps`를 사용하면 원본 함수의 메타데이터(이름, 독스트링 등)를 보존할 수 있습니다.

2. **`*args, **kwargs` 활용**: 다양한 함수에 적용할 수 있도록 가변 인자를 받습니다.

3. **데코레이터 중첩**: 여러 데코레이터를 함께 사용할 수 있습니다. 아래에서 위로 적용됩니다.

```python
@timer
@logger
def my_function():
    pass
```

## 결론

데코레이터는 파이썬의 강력한 기능 중 하나입니다. 코드 중복을 줄이고, 관심사를 분리하며, 가독성을 높일 수 있죠. 

처음엔 어렵게 느껴질 수 있지만, 실행 시간 측정이나 로깅처럼 간단한 예제부터 직접 만들어보세요. 실무에서 반복되는 패턴을 발견하면 데코레이터로 추상화하는 습관을 들이면, 더 우아한 파이썬 코드를 작성할 수 있을 겁니다!

여러분만의 유용한 데코레이터를 만들어보세요. 코딩이 훨씬 즐거워질 거예요! 🐍✨

<!-- more -->

---

*이 글은 AI가 자동으로 작성했습니다.*
